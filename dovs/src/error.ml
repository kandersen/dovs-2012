(** Functions and type declarations having to do with error handling. *)

(** Function for signaling a "hole" that needes to completed towards a full joos compiler *)
let joos_not_implemented_yet file msg =
  Printf.printf "Implementation needed in %s:\n\t%s\n" file msg;
  exit 0 (* exit as a success to allow partial "negative" testing *)

(** Error types accepted/expected by the testing framework *)
type errortype =
  | ABSTRACT_FINAL_CLASS
  | ABSTRACT_METHOD_BODY
  | ABSTRACT_METHOD_FINAL_OR_STATIC
  | FORMAL_INITIALIZER
  | INTERFACE_CONSTRUCTOR
  | INTERFACE_FIELD
  | INTERFACE_METHOD_WITH_BODY
  | INVALID_INTEGER
  | INVALID_SOURCE_FILE_NAME
  | JOOS1_EXPLICIT_SUPER_CALL
  | JOOS1_FINAL_FIELD_DECLARATION
  | JOOS1_INC_DEC
  | JOOS1_INTERFACE
  | JOOS1_MULTI_ARRAY
  | JOOS1_OMITTED_CONSTRUCTOR
  | JOOS1_STATIC_FIELD_DECLARATION
  | JOOS1_THIS_CALL
  | JOOS1_THROW
  | MISSING_FINAL_FIELD_INITIALIZER
  | NON_ABSTRACT_METHOD_BODY
  | PARSER_EXCEPTION
  | STATIC_FINAL_METHOD
  | STATIC_OR_FINAL_INTERFACE_METHOD
  | SUPER_CALL_NOT_FIRST_STATEMENT
  | SYNTAX_ERROR
  | THIS_CALL_NOT_FIRST_STATEMENT
  | VOID_TYPE_ARRAY
  | VOID_TYPE_CAST
  | VOID_TYPE_FIELD
  | VOID_TYPE_INSTANCEOF
  | VOID_TYPE_NOT_RETURN_TYPE
  | VOID_TYPE_VARIABLE
  | DUPLICATE_FIELD
  | DUPLICATE_TYPE
  | DUPLICATE_VARIABLE
  | AMBIGUOUS_CLASS_NAME
  | NON_EXISTING_PACKAGE
  | PREFIX_RESOLVES_TO_TYPE
  | SINGLE_TYPE_IMPORT_CLASH_WITH_CLASS
  | TWO_SINGLE_TYPE_IMPORTS_CLASH
  | UNRESOLVED_TYPE
  | CIRCULAR_INHERITANCE
  | CLASS_MUST_BE_ABSTRACT
  | DIFFERENT_RETURN_TYPE
  | DUPLICATE_CONSTRUCTOR
  | DUPLICATE_METHOD
  | EXTENDS_FINAL_CLASS
  | EXTENDS_NON_CLASS
  | ILLEGAL_THROWS_IN_REPLACE
  | IMPLEMENTS_NON_INTERFACE
  | INHERITED_FIELD_CLASH
  | NONSTATIC_REPLACE_STATIC
  | PACKAGE_CLASH_WITH_TYPE
  | PROTECTED_REPLACE_PUBLIC
  | REPEATED_INTERFACE
  | REPLACE_FINAL
  | STATIC_REPLACE_NONSTATIC
  | ILLEGAL_FORWARD_FIELD_REFERENCE
  | ILLEGAL_FORWARD_STATIC_FIELD_REFERENCE
  | JOOS1_IMPLICIT_THIS_CLASS_STATIC_FIELD
  | VARIABLE_NOT_FOUND
  | VARIABLE_OR_TYPE_NOT_FOUND
  | AMBIGUOUS_OVERLOADING
  | ASSIGN_TO_ARRAY_LENGTH
  | ASSIGN_TO_FINAL_FIELD
  | ASSIGN_TYPE
  | BINOP_TYPE
  | CIRCULAR_CONSTRUCTOR_INVOCATION
  | CONSTRUCTOR_NAME
  | FIELD_NOT_FOUND
  | FIELD_ON_ARRAY
  | FIELD_ON_NON_REFERENCE
  | ILLEGAL_THROWS
  | INSTANTIATE_ABSTRACT_CLASS
  | INSTANTIATE_INTERFACE
  | INVALID_CAST
  | INVALID_INSTANCEOF
  | JOOS1_ARRAY_METHOD_CALL
  | JOOS1_BITWISE_OPERATIONS
  | JOOS1_CLOSEST_MATCH_OVERLOADING
  | JOOS1_IMPLICIT_THIS_CLASS_STATIC_METHOD
  | NO_MATCHING_CONSTRUCTOR_FOUND
  | NO_MATCHING_METHOD_FOUND
  | NON_ARRAY_TYPE_ARRAY_BASE
  | NON_BOOLEAN_CONDITION 
  | NON_JOOS_FIELD_TYPE
  | NON_JOOS_PARAMETER_TYPE
  | NON_JOOS_RETURN_TYPE
  | NON_NUMERIC_ARRAY_INDEX
  | NON_NUMERIC_ARRAY_SIZE
  | NON_NUMERIC_INC_DEC
  | NON_REFERENCE_RECEIVER
  | NON_THROWABLE_IN_THROWS
  | NONSTATIC_FIELD_LINKED_AS_STATIC
  | NONSTATIC_METHOD_LINKED_AS_STATIC
  | PROTECTED_CONSTRUCTOR_INVOCATION 
  | PROTECTED_MEMBER_ACCESS
  | STATIC_FIELD_LINKED_AS_NONSTATIC
  | STATIC_METHOD_LINKED_AS_NONSTATIC
  | THIS_BEFORE_SUPER_CALL
  | THIS_IN_STATIC_CONTEXT
  | UNOP_TYPE
  | VOID_RETURN_IN_NON_VOID_METHOD
  | MISSING_RETURN_STATEMENT
  | UNREACHABLE_STATEMENT
  | JOOS1_LOCAL_VARIABLE_IN_OWN_INITIALIZER
  | JOOS1_OMITTED_LOCAL_INITIALIZER
  | VARIABLE_MIGHT_NOT_HAVE_BEEN_INITIALIZED
  | UNRESOLVED_TYPE_ERROR
  | FILE_OPEN_ERROR
  | MAKE_TYPE_ERROR
  | ARGUMENT_ERROR
  | INTERNAL_COMPILER_ERROR
  | LEXER_EXCEPTION
  | PEEPHOLE
  | RUN_EXCEPTION
  | UNKNOWN

(** Convertion from an error type (enum) to an exit status code *)
let errortype_to_errorcode e = match e with
  | ABSTRACT_FINAL_CLASS -> 100
  | ABSTRACT_METHOD_BODY -> 101
  | ABSTRACT_METHOD_FINAL_OR_STATIC -> 102
  | FORMAL_INITIALIZER -> 103
  | INTERFACE_CONSTRUCTOR -> 104
  | INTERFACE_FIELD -> 105
  | INTERFACE_METHOD_WITH_BODY -> 106
  | INVALID_INTEGER -> 107
  | INVALID_SOURCE_FILE_NAME -> 108
  | JOOS1_EXPLICIT_SUPER_CALL -> 109
  | JOOS1_FINAL_FIELD_DECLARATION -> 110
  | JOOS1_INC_DEC -> 111
  | JOOS1_INTERFACE -> 112
  | JOOS1_MULTI_ARRAY -> 113
  | JOOS1_OMITTED_CONSTRUCTOR -> 114
  | JOOS1_STATIC_FIELD_DECLARATION -> 115
  | JOOS1_THIS_CALL -> 116
  | JOOS1_THROW -> 117
  | MISSING_FINAL_FIELD_INITIALIZER -> 118
  | NON_ABSTRACT_METHOD_BODY -> 119
  | PARSER_EXCEPTION -> 120
  | STATIC_FINAL_METHOD -> 121
  | STATIC_OR_FINAL_INTERFACE_METHOD -> 122
  | SUPER_CALL_NOT_FIRST_STATEMENT -> 123
  | SYNTAX_ERROR -> 124
  | THIS_CALL_NOT_FIRST_STATEMENT -> 125
  | VOID_TYPE_ARRAY -> 126
  | VOID_TYPE_CAST -> 127
  | VOID_TYPE_FIELD -> 128
  | VOID_TYPE_INSTANCEOF -> 129
  | VOID_TYPE_NOT_RETURN_TYPE -> 130
  | VOID_TYPE_VARIABLE -> 131
  | DUPLICATE_FIELD -> 132
  | DUPLICATE_TYPE -> 133
  | DUPLICATE_VARIABLE -> 134
  | AMBIGUOUS_CLASS_NAME -> 135
  | NON_EXISTING_PACKAGE -> 136
  | PREFIX_RESOLVES_TO_TYPE -> 137
  | SINGLE_TYPE_IMPORT_CLASH_WITH_CLASS -> 138
  | TWO_SINGLE_TYPE_IMPORTS_CLASH -> 139
  | UNRESOLVED_TYPE -> 140
  | CIRCULAR_INHERITANCE -> 141
  | CLASS_MUST_BE_ABSTRACT -> 142
  | DIFFERENT_RETURN_TYPE -> 143
  | DUPLICATE_CONSTRUCTOR -> 144
  | DUPLICATE_METHOD -> 145
  | EXTENDS_FINAL_CLASS -> 146
  | EXTENDS_NON_CLASS -> 147
  | ILLEGAL_THROWS_IN_REPLACE -> 148
  | IMPLEMENTS_NON_INTERFACE -> 149
  | INHERITED_FIELD_CLASH -> 150
  | NONSTATIC_REPLACE_STATIC -> 151
  | PACKAGE_CLASH_WITH_TYPE -> 152
  | PROTECTED_REPLACE_PUBLIC -> 153
  | REPEATED_INTERFACE -> 154
  | REPLACE_FINAL -> 155
  | STATIC_REPLACE_NONSTATIC -> 156
  | ILLEGAL_FORWARD_FIELD_REFERENCE -> 157
  | ILLEGAL_FORWARD_STATIC_FIELD_REFERENCE -> 158
  | JOOS1_IMPLICIT_THIS_CLASS_STATIC_FIELD -> 159
  | VARIABLE_NOT_FOUND -> 160
  | VARIABLE_OR_TYPE_NOT_FOUND -> 161
  | AMBIGUOUS_OVERLOADING -> 162
  | ASSIGN_TO_ARRAY_LENGTH -> 163
  | ASSIGN_TO_FINAL_FIELD -> 164
  | ASSIGN_TYPE -> 165
  | BINOP_TYPE -> 166
  | CIRCULAR_CONSTRUCTOR_INVOCATION -> 167
  | CONSTRUCTOR_NAME -> 168
  | FIELD_NOT_FOUND -> 169
  | FIELD_ON_ARRAY -> 170
  | FIELD_ON_NON_REFERENCE -> 171
  | ILLEGAL_THROWS -> 172
  | INSTANTIATE_ABSTRACT_CLASS -> 173
  | INSTANTIATE_INTERFACE -> 174
  | INVALID_CAST -> 175
  | INVALID_INSTANCEOF -> 176
  | JOOS1_ARRAY_METHOD_CALL -> 177
  | JOOS1_BITWISE_OPERATIONS -> 178
  | JOOS1_CLOSEST_MATCH_OVERLOADING -> 179
  | JOOS1_IMPLICIT_THIS_CLASS_STATIC_METHOD -> 180
  | NO_MATCHING_CONSTRUCTOR_FOUND -> 181
  | NO_MATCHING_METHOD_FOUND -> 182
  | NON_ARRAY_TYPE_ARRAY_BASE -> 183
  | NON_BOOLEAN_CONDITION  -> 184
  | NON_JOOS_FIELD_TYPE -> 185
  | NON_JOOS_PARAMETER_TYPE -> 186
  | NON_JOOS_RETURN_TYPE -> 187
  | NON_NUMERIC_ARRAY_INDEX -> 188
  | NON_NUMERIC_ARRAY_SIZE -> 189
  | NON_NUMERIC_INC_DEC -> 190
  | NON_REFERENCE_RECEIVER -> 191
  | NON_THROWABLE_IN_THROWS -> 192
  | NONSTATIC_FIELD_LINKED_AS_STATIC -> 193
  | NONSTATIC_METHOD_LINKED_AS_STATIC -> 194
  | PROTECTED_CONSTRUCTOR_INVOCATION  -> 195
  | PROTECTED_MEMBER_ACCESS -> 196
  | STATIC_FIELD_LINKED_AS_NONSTATIC -> 197
  | STATIC_METHOD_LINKED_AS_NONSTATIC -> 198
  | THIS_BEFORE_SUPER_CALL -> 199
  | THIS_IN_STATIC_CONTEXT -> 200
  | UNOP_TYPE -> 201
  | VOID_RETURN_IN_NON_VOID_METHOD -> 202
  | MISSING_RETURN_STATEMENT -> 203
  | UNREACHABLE_STATEMENT -> 204
  | JOOS1_LOCAL_VARIABLE_IN_OWN_INITIALIZER -> 205
  | JOOS1_OMITTED_LOCAL_INITIALIZER -> 206
  | VARIABLE_MIGHT_NOT_HAVE_BEEN_INITIALIZED -> 207
  | UNRESOLVED_TYPE_ERROR -> 208
  | FILE_OPEN_ERROR -> 209
  | MAKE_TYPE_ERROR -> 210
  | ARGUMENT_ERROR -> 211
  | INTERNAL_COMPILER_ERROR -> 212
  | LEXER_EXCEPTION -> 213
  | PEEPHOLE -> 214
  | RUN_EXCEPTION -> 215
  | UNKNOWN -> 216

(**/**) (*/*)

let print_position pos =
    let line = pos.Lexing.pos_lnum in
    let cnum = pos.Lexing.pos_cnum - pos.Lexing.pos_bol in
    Printf.printf " line %i, column %i:" line cnum 

let rec print_line pos =
  let inch = open_in pos.Lexing.pos_fname in
  let rec read_line i = match i with
    | 1 -> input_line inch;
    | n -> let _ = input_line inch in
	   read_line (i-1) in
  let line =
    try read_line pos.Lexing.pos_lnum
    with End_of_file ->
      print_endline "Warning: attempt to print invalid Lexing.position: line index out of bounds";
      "" in
  close_in inch;
  print_endline line;
  let rec print_col i col =
    if i > col
    then print_string "^"
    else begin
      (match line.[i] with
        | '\t' -> print_char '\t'
        | _    -> print_char ' ');
      print_col (i+1) col
    end
  in try print_col 0 (pos.Lexing.pos_cnum - pos.Lexing.pos_bol - 1)
    with Invalid_argument _ ->
      print_newline ();
      print_endline "Warning: attempt to print invalid Lexing.position: column index out of bounds"

(**/**) (*/*)

(** Exit with error [errortype] at position [pos] and message [message] *)
let error errortype pos message =
  if pos = Lexing.dummy_pos
  then
    begin
      print_string "Error: ";
      print_endline message;
      exit (errortype_to_errorcode errortype)
    end
  else
    begin
      print_string ("File \"" ^ pos.Lexing.pos_fname ^"\",");
      print_position pos;
      print_newline ();
      print_string "Error: ";
      print_endline message;
      print_newline ();
      print_line pos;
      print_newline ();
      exit (errortype_to_errorcode errortype)
    end

(** Raise an internal compiler error with [message] *)
let internal_compiler_error message =
  error INTERNAL_COMPILER_ERROR Lexing.dummy_pos message

(** If [-joos1] is set exit with [errortype], [pos] and [message] *)
let check_joos1 errortype pos message =
  if !Globals.joos1 
  then error errortype pos ("Joos 2 feature used: " ^ message)
  else ()
