#-*- mode: org; coding: utf-8-dos; -*-
#
#+TITLE:     dOvs 2011 -- README.txt
#+DATE:      Time-stamp: <2012-08-24 06:20:48 jmi>
#+AUTHOR:    Ian Zerny
#+EMAIL:     zerny@cs.au.dk
#+LINK_HOME: http://cs.au.dk/dOvs
#+BEGIN_HTML
<link href="style.css" rel=stylesheet type="text/css" />
#+END_HTML
# --------------------------------------------------------------------
#
# This README file contains help for compiling and using the Joos
# compilers for the dOvs course. You can find the latest version as a
# nice HTML file at:
#
#   http://cs.au.dk/~mis/dOvs/README.html
#
# Alternatively you can simply browse this text file, or generate an
# HTML file from it with Emacs. Simply open this file and type:
#
#   C-c C-e h
#
# This will generate the file README.html
#
# If you browse the raw text version notice the markup conventions:
#
#   *bold*
#   /italic/
#   =inline code=
#
# And a block of code or an example is prefixed with colons.
# For example:
#
#   : let foo () =
#   :   print_string "Hello ";
#   :   print_string "World!";
#   :   print_newline ()
#
# The rest should be fairly clear from the context.
#
# When browsing with Emacs, use TAB to expanded/collapsed sections.
#
# Happy Hacking!
# --------------------------------------------------------------------

The goal of this project is to write in OCaml a compiler translating
from Joos (a subset of Java) to Java bytecode.

The compiler project is split into a number of phases which are run on
the input program in sequence to produce the final output. These
phases are grouped into a number of hand-in assignments. The
responsibilities of each phase, and the interfaces between them, are
precisely defined in the hand-in assignment descriptions on the
[[http://cs.au.dk/dOvs][dOvs home page]].

This document describes compiling and using the Caml Joos compiler
skeleton. For help on installing the prerequisites consult the
[[file:INSTALL.html][INSTALL.txt]] document.

* The Joos languages

Three different subsets of Java are defined: Joos 0, Joos 1 and
Joos 2. These are ordered such that Joos 0 is a subset of Joos 1,
which is a subset of Joos 2, which is a subset of Java 1.3. The
languages are defined by the [[http://www.cs.au.dk/~mis/dOvs/languages.html][Java features]] which they contain.

 * Joos 0 is a very simple language. A compiler for Joos 0 is given as
   an example of a complete compiler, which can be used as inspiration
   for the project.

 * Joos 1 defines the minimum set of language features your compiler
   must support. A skeleton for a Joos 1 compiler is given. Your job
   is to fill out the (many) missing parts to obtain a complete Joos 1
   compiler.

 * Joos 2 defines a set of additional language features you can
   implement support for in your compiler in order to earn extra
   credit. An executable reference implementation of Joos 2 is
   available.


* Command-line arguments

  The compiler takes (along with the list of source files to compile)
  the following commandline arguments:

  * =-joos1= :: Tells the reference compiler to reject programs that
    use language features not in Joos 1. You are not required (though
    welcome) to support this switch in your own compiler.

  * =-peephole= :: Tells the reference compiler to perform peephole
    optimizations on the generated byte code.

  * =-noverify= :: Do not abort the compilation if some internal code
    consistency checks fail (in the =Limits= phase). Useful when
    debugging the code generation and optimization phases.

  * =-classpath classpath= (or =-cp classpath=) :: Specify the
    classpath where the compiler should search for library class
    files.


* The skeleton file hierarchy

  - README.txt :: Contains the source for this file.

  - INSTALL.txt :: Contains help for installing and using tools needed
    for dOvs.

  - Makefile :: Provides targets for building the Joos skeleton
    compiler. (See Section [[Building]].)

  - runtests :: Provides local testing support. (See Section [[Testing]].)

  - joos.* :: Are (symlinks to) the generated Joos skeleton compiler.
    (See Section [[Building]].)

  - src/ :: Contains all of the OCaml source files for the Joos skeleton.

  - lib/ :: Contains OCaml libraries, the testing framework and the
    Java 1.3 runtime library needed for accessing classes in the Java
    Standard Library. (See Section [[Building]] to install the libraries.)

  - tests/ :: Contains Java programs for locally testing the Joos
    skeleton compiler. (See Section [[Testing]].)

  - doc/ :: This directory is generated after building the
    documentation for the Joos skeleton compiler. (See Section
    [[Building]].)

  - \_build/ :: This directory is generated when building the Joos
    skeleton compiler. It contains all the generated object code and
    executables.


* Building the Joos skeleton compiler
# <<Building>>

  To build the Joos compiler you should use the provided Makefile. It
  contains targets for installing libraries, building documentation
  and building your Joos compiler. The make system is invoked with the
  command line:

  : user@host$ make [target]

  where =[target]= is one of:

  - =joos.byte= :: Build the Joos skeleton as OCaml byte code.
  - =joos.native= :: Build the Joos skeleton as native machine code.
  - =joos.top= :: Build an interactive toplevel for the Joos skeleton.
  - =joos.debug= :: Build the Joos skeleton with debugging support.
  - =joos.profile= :: Build the Joos skeleton with profiling support.
  - =htdoc= :: Build documentation for the Joos skeleton.
  - =clean= :: Clean (i.e., remove) the generated files.
  - =libs= :: Install library dependencies for the Joos skeleton.

  Each of these targets are described below.
  If no target is given, then =joos.byte= is the default target.
  (You can change this default by editing the Makefile.)

** The =joos.byte= and =joos.native= targets

   These two targets will build the Joos skeleton compiler. Each will
   produce two files (symbolic links) =joos= and either =joos.byte= or
   =joos.native= which all point to the compiled compiler. To invoke
   the compiler simply run:

   : user@host$ ./joos <args>

   where the arguments are those described in Section [[*Command-line arguments][Command-line arguments]].

** The =joos.top= target

   This target builds an OCaml toplevel, =joos.top=, where the Joos
   skeleton is already preloaded. To start the toplevel simply run it
   and if you use =rlwrap= it will allow you to edit the input line:

   : user@host$ rlwrap ./joos.top
   :
   : Welcome to the dOvs CamlJoos compiler, version 2011.
   : ...
   : # 

   Now you can type in the usual OCaml expressions, including
   expressions that use code from the Joos skeleton.

** The =joos.debug= target

   /Disclaimer: the OCaml debugger does not work on Windows due to an
   error in the current version of flexdll in Cygwin./
   /Students in need of the debugger are advised to build and debug on
   the Universities linux machines./

   This target builds =joos.debug=, a byte-code Joos skeleton with
   debugging symbols. You can then debug the application with
   =ocamldebug= allowing you to insert breakpoints and step through
   the code. For example:

   : user@host$ ocamldebug joos.debug
   : 	Objective Caml Debugger version 3.11.2
   : 
   : (ocd) set arguments test.java
   : (ocd) run

   More information about using the debugger can be found in the 
   [[http://caml.inria.fr/pub/docs/manual-ocaml/manual030.html][OCaml manual]]. It also describes debugging from within Emacs.

** The =joos.profile= target

   This target builds =joos.native=, a native-code Joos skeleton
   instrumented with profiling output. You can then profile the
   application with =gprof=. For example:

   : user@host$ ./joos.profile test.java
   : ...
   : user@host$ gprof joos.profile

   More information profiling can be found in [[http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html][gprof manual]].

** The =htdoc= target

   This target builds JavaDoc style documentation for the Joos
   skeleton. The generated documentation index is found at
   =doc/index.html=.

** The =clean= target

   This target simply cleans up most of the files produced during
   compilation, including the generated binaries. It does not remove
   the unpacked library files in =lib=. After installing libraries you
   can safely remove the tar files (but *don't* remove the
   testdriver!).

** The =libs= target

   This target installs libraries that are needed to compile the Joos
   skeleton. This includes findlib and javalib. The build system will
   inform you if you need to perform this step.


* Testing the Joos skeleton compiler
# <<Testing>>

** Local testing

  The Joos skeleton comes with a =runtests= script to allow local
  testing of the skeleton compiler. The =runtests= script invokes the
  compiler on a selection of tests relevant to a selection of
  phases. The result of running the tests is printed to the local file
  =results.html= which can be viewed in a browser. The script is invoked as:

  : user@host$ ./runtests [options] <tests-dir>

  where =<tests-dir>= is a directory of Java test programs and the
  optional =options= are:

  * =-1= :: For each test invoke the compiler with the =-joos1= flag.

  * =-r= :: For each test, after compiling, link the generated code
    and execute the test program.

  * =-p <phases>= :: Select only tests relevant to the specified
    phases. If this flag is omitted, a /complete test/ is run.
    =<phases>= can be any non-empty combination of:

    - =W= : Parsing and Weeding
    - =N= : Name Resolving
    - =E= : Environment building
    - =H= : Hierarchy
    - =D= : Disambiguation
    - =T= : Type Checking
    - =R= : Reachability
    - =A= : Definite Assignment
    - =L= : Resources
    - =C= : Code Generation
    - =O= : Optimization

  * =-c <compiler>= :: Use =<compiler>= as the Joos compiler to test.
    (Defaults to =./joos=.)

  * =-h= :: Print help information, including the list of correct
    phase letters.

** Online testing

  On your group page, you have the possibility of testing a selection
  of compiler phases on the supplied test suite of Java programs. This
  will build a compiler using your implementation of the selected
  phases and the reference implementation for the rest and run this
  compiler on all the test programs relevant for the selected phases.

  Each group is allowed to perform 6 /complete tests/ per day which
  run the testing framework on all testcases and not just the relevant
  ones. The complete tests should be used once in a while since they
  might show some errors inadvertently hidden in the non-relevant
  testcases.

** Test results

  Depending on the outcome, each test case will be marked as either
  passing or failing.

  The test cases are divided into three categories: negative, positive
  Joos 1 and positive Joos 2.

  * Negative cases are marked as as =[OKAY]= if the compiler produces an
    error message and =[FAIL]= otherwise.

  * Positive Joos 1 cases are marked as =[OKAY]= if the program
    compiles, assembles and runs correctly and =[FAIL]= otherwise.

  * Positive Joos 2 cases are marked as =[JOOS2]= if the program
    compiles, assembles and runs correctly, =[JOOS1]= if the compiler
    produces an error message and =[FAIL]= otherwise.

  A pure Joos 1 compiler will produce =[OKAY]= on all negative cases
  positive Joos 1 cases and =[JOOS1]= on all positive Joos 2 cases. A
  pure Joos 2 compiler will produce =[OKAY]= on all negative cases and
  positive Joos 1 cases and =[JOOS2]= on all positive Joos 2 cases.

  A Joos compiler is said to be correct with respect to the test suite
  (a necessary but not sufficient condition for being a correct Joos
  compiler) if it produces no =[FAIL]= results.

  To reduce the workload of the testing system each testcase has been
  marked with a set of relevant phases, and a testcase is included in
  the testrun only if the selected phases include one of the relevant
  phases.


* Support modules

  In addition to the skeleton phases, the compiler skeleton contains a
  number of support modules which you are advised to familiarize
  yourself with:

  - Main :: The command-line interface to the compiler.

  - Error :: Error reporting functions and a datatype of all possible
    compiler errors. Any error in the input program should be reported
    through the functions in this module.
    FIXME: but we add helpers in each phase prelude...

  - Classenvironment :: Interface to the class library. Contains
    functions for searching the classpath for class files and reading
    these class files.

  - Classfileparser :: Used by Classenvironment to parse Java class files.

  - Utils :: Contains various helper functions you may find useful.


* Support tools

  You will be using the following tools for the project. However, most
  of the tools will be invoked implicitly by the build system (i.e., make).

  - GNU Make :: Use the Makefile provided, since it contains all the
    right options and dependencies for building the Joos compiler.

  - ocamlc / ocamlopt :: The OCaml (bytecode/native code)
    compiler. Used to compile the Joos compiler.

  - ocamlfind :: Compiler utility to search for installed Ocaml
    modules.

  - ocamllex :: Scanner generator.

  - menhir :: Parser generator.

  - jasmin :: Java bytecode assembler. Used to translate the .j files
    produced by the Joos compiler into Java class files.

  - JavaLib :: Java Bytecode Library. Used by Classfileparser to
    parse class files.

  - /users/dovs/bin/camljoos2 :: The new reference Joos 2 compiler
    (implemented in OCaml).

  - /users/dovs/bin/joos2c :: The old reference Joos 2 compiler
    (implemented in Java).


* The =-joos1= switch

  Giving the =-joos1= commandline switch to the compiler (or selecting
  the =-joos1= option from the group page) will make the reference
  implementation of the compiler phases behave as a Joos 1 compiler
  rather than a Joos 2 compiler. For all phases except =Codegeneration=,
  all this switch does is to reject programs that use certain Joos 2
  language features as defined in the assignment descriptions for each
  phase. Since a Joos 1 implementation of a compiler phase may assume
  that these rejections have been done properly in all previous
  phases, even a correct Joos 1 phase may produce failures on Joos 2
  programs if some of the previous phases implement Joos 2
  behavior. In other words:

  * If you are running with the =-joos1= switch, your compiler has to
    produce no failures, no matter how you combine your phases with
    the reference implementation.

  * If you are running without the =-joos1= switch, and your compiler
    does not implement all Joos 2 language features, and you have a
    reference implementation phase running before one of your own
    phases, then failures among the positive Joos 2 tests are
    acceptable.

  A full Joos 2 compiler must of course produce correct Joos 2 results
  when mixed with the reference implementation phases running without
  the =-joos1= switch.


* Transformations, implementations and checks

The skeleton source code contains files implementing various
/compiler phases/ for compiling a Joos source file.
The online assignment descriptions describe each individual
phase, which files that belong to a phase and what they must implement.

Some phases *transform* between different ASTs,
i.e., they rewrite parts of the AST based on newly calculated information.
Other phases *transform* an AST to supplementary structures,
e.g., they might collect information about the classes in a program.

Some phases *implement* functions that later phases can call to query
the calculated information.

Some phases *check* to validate the correctness of an AST or
supplementary structure. If any of these checks fail, the compiler
must produce an error message (using the =error_foo= or
=check_joos1_foo= functions available in each phase).

You may not alter the modules defining the ASTs (except for the file
=ast.ml=) or any of the interface =.mli= files that specify the
interfaces of the phases. However you are welcome to add any functions
and variables to the modules that you find useful in implementing the
individual phases. You can also put common utility code in =utils.ml=.

------------------------------------------------------------

* Editor integration

** Emacs (using Tuareg Mode)

   If you have installed Tuareg according to the [[file:INSTALL.html][INSTALL.txt]] you are
   ready to go. Simply open up a file in the =dovs/src= directory of
   the skeleton. Now press =C-c C-c=, that is /Control + c, Control + c/.
   This will prompt for the target to compile:

   : Compile command: make -k

   The default target is fine so just hit enter. Alternatively, you
   can type what target you would like to run, for example:

   : Command command: make -k clean

   to clean up a previous build.

   Use =C-h m= to read more about the features of Tuareg or check out
   this fine cheat sheet for Tuareg:
     http://www.ocamlpro.com/files/tuareg-mode.pdf


** Eclipse (using OcaIDE)

   * Option 1 ::
   In OcaIDE, the easiest way to get running is to import the =dovs=
   folder as an existing project managed by a =Makefile=. Right click
   in the /Navigator/ window and select import. In the import window
   select /General > Existing Projects into Workspace/, select the
   =dovs= folder as the /root directory/ and select if you want the
   project to be copied into your workspace folder or not (most likely
   not).

   After successfully importing you should disable /Project > Build
   Automatically/. Now use the /Ctrl + B/ to compile the project.

   * Option 2 ::
   Alternatively, you can create a new /OCaml Project (ocamlbuild)/
   and manually add the correct dependencies by right clicking your
   project and selecting /Properties > Project/. Here you will want to
   add the following:
   - /Targets/: =src/main.byte=
   - /Libraries/: =str,unix,ptrees,zip,extLib,javalib=
   - /Compiler flags/: =-I,<ptrees>,-I,<javalib>,-I,<camlzip>,-I,<extlib>=
   - /Linker flags/: =-I,<ptrees>,-I,<javalib>,-I,<camlzip>,-I,<extlib>,-dllpath,<ptrees>,-dllpath,<javalib>,-dllpath,<camlzip>,-dllpath,<extlib>=

   Here replace =<lib>= with the actual location of the library. You
   can find the location with =ocamlfind=. For example:

   : user@host$ ocamlfind query extlib
   : /usr/lib/ocaml/site-lib/extlib


------------------------------------------------------------
