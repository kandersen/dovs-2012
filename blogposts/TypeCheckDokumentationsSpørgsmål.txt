Explain the difference between the static type of an expression (the type bound by the exp_type field) and the dynamic type of an expression (the type of the expression at run time).
The static type of an expression doesn't have to be the actual run time type of the same expression. In java we have both interfaces and super classes and these both influence the run time type of an expression. If an expression has static type A at run time i may have any type B such that B is a sub type of A. Similar for interface one can declare an expression of interface type but at run time this expression will have the type of some implementation of that interface or an error occurs. The promise the type checking provide is that the static type actually type checks in the current content but it is not certain that the static type will be the same as the run time type. This becomes even more complicated if we use the joos 2 feature of closest match on methods and constructors since what appears to be obvious at compile time turns out to something completely different at run time. 

Explain why we do not check whether an invoked method is abstract or not.
We don't need to check this since at run time abstract methods cannot exists since it is impossible to instantiate an instance of an abstract class or interface. It still makes sense to have abstract methods at compile time since any static type can be any sub type at run time. If the run time type is not abstract the method call can be performed. The is most apparent with interfaces. One can create a field or local variable of an interface type and then invoke a method on this field or local variable. This of course does not make any sense at compile time since all interface methods are abstract but since it is impossible to actaully instantiate an instance of an interface at run time an implementation of the interface must have been provided and stored in the field or local before the actual execution will take place. Maybe no implementaion has been provided then the field or local simple holdes a null reference since it is impossible to create an instance of an interface or abstract class. So basically we don't need to check abstract methods since they cannot exist at run time either an implementation has been provided or a null pointer exception occures. 
